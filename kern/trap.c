#include <inc/mmu.h>
#include <inc/x86.h>
#include <inc/assert.h>

#include <kern/pmap.h>
#include <kern/trap.h>
#include <kern/console.h>
#include <kern/monitor.h>

static struct Taskstate ts;

/* Interrupt descriptor table.  (Must be built at run time because
 * shifted function addresses can't be represented in relocation records.)
 */
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {
	sizeof(idt) - 1, (uint32_t) idt
};


static const char *trapname(int trapno)
{
	static const char * const excnames[] = {
		"Divide error",
		"Debug",
		"Non-Maskable Interrupt",
		"Breakpoint",
		"Overflow",
		"BOUND Range Exceeded",
		"Invalid Opcode",
		"Device Not Available",
		"Double Falt",
		"Coprocessor Segment Overrun",
		"Invalid TSS",
		"Segment Not Present",
		"Stack Fault",
		"General Protection",
		"Page Fault",
		"(unknown trap)",
		"x87 FPU Floating-Point Error",
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
		return excnames[trapno];
	if (trapno == T_SYSCALL)
		return "System call";

	return "(unknown trap)";
}


void
idt_init(void)
{
	extern struct Segdesc gdt[];
	
	// LAB 2: Your code here.
    extern uint32_t handler0;// divide error    
    extern uint32_t handler1;// debug exception
    extern uint32_t handler2;// non-maskable interrupt
    extern uint32_t handler3;// breakpoint
    extern uint32_t handler4;// overflow
    extern uint32_t handler5;// bounds check
    extern uint32_t handler6;// illegal opcode
    extern uint32_t handler7;// device not available 
    extern uint32_t handler8;// double fault
    extern uint32_t handler9;// reserved (not generated by recent processors)
    extern uint32_t handler10;// invalid task switch segment
    extern uint32_t handler11;// segment not present
    extern uint32_t handler12;// stack exception
    extern uint32_t handler13;// general protection fault
    extern uint32_t handler14;// page fault
    extern uint32_t handler15;// reserved
    extern uint32_t handler16;// floating point error
    extern uint32_t handler17;// aligment check
    extern uint32_t handler18;// machine check
    extern uint32_t handler19;// SIMD floating point error
    extern uint32_t handler48;// System Call

    SETGATE(idt[1],1,GD_KT,&handler1,0);
    SETGATE(idt[2],1,GD_KT,&handler2,0);
    SETGATE(idt[3],1,GD_KT,&handler3,3);//intercept accessible from userlevel
    SETGATE(idt[4],1,GD_KT,&handler4,0);
    SETGATE(idt[5],1,GD_KT,&handler5,0);
    SETGATE(idt[6],1,GD_KT,&handler6,0);
    SETGATE(idt[7],1,GD_KT,&handler7,0);
    SETGATE(idt[8],1,GD_KT,&handler8,0);
    SETGATE(idt[9],1,GD_KT,&handler9,0);
    SETGATE(idt[10],1,GD_KT,&handler10,0);
    SETGATE(idt[11],1,GD_KT,&handler11,0);
    SETGATE(idt[12],1,GD_KT,&handler12,0);
    SETGATE(idt[13],1,GD_KT,&handler13,0);
    SETGATE(idt[14],1,GD_KT,&handler14,0);
    SETGATE(idt[15],1,GD_KT,&handler15,0);
    SETGATE(idt[16],1,GD_KT,&handler16,0);
    SETGATE(idt[17],1,GD_KT,&handler17,0);
    SETGATE(idt[18],1,GD_KT,&handler18,0);
    SETGATE(idt[19],1,GD_KT,&handler19,0);

	// Set a gate for the system call interrupt.
	// Hint: Must this gate be accessible from userlevel?
	// LAB 3: Your code here.
    SETGATE(idt[48],0,GD_KT,&handler48,3); 

	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	ts.ts_esp0 = KSTACKTOP;
	ts.ts_ss0 = GD_KD;

	// Initialize the TSS field of the gdt.
	gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32_t) (&ts),
					sizeof(struct Taskstate), 0);
	gdt[GD_TSS >> 3].sd_s = 0;

	// Load the TSS
	ltr(GD_TSS);

	// Load the IDT
	asm volatile("lidt idt_pd");
}


void
print_trapframe(struct Trapframe *tf)
{
	cprintf("TRAP frame at %p\n", tf);
	print_regs(&tf->tf_regs);
	cprintf("  es   0x----%04x\n", tf->tf_es);
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
	cprintf("  err  0x%08x\n", tf->tf_err);
	cprintf("  eip  0x%08x\n", tf->tf_eip);
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
	cprintf("  esp  0x%08x\n", tf->tf_esp);
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
}

void
print_regs(struct Registers *regs)
{
	cprintf("  edi  0x%08x\n", regs->reg_edi);
	cprintf("  esi  0x%08x\n", regs->reg_esi);
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
	cprintf("  edx  0x%08x\n", regs->reg_edx);
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
	cprintf("  eax  0x%08x\n", regs->reg_eax);
}

void
trap(struct Trapframe *tf)
{
	// Dispatch based on what type of trap occurred
	switch (tf->tf_trapno) {

	// LAB 2: Your code here.
    case T_BRKPT:
        monitor(tf);
        break;

	default:
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
		if (tf->tf_cs == GD_KT)
			panic("unhandled trap in kernel");
		else
			panic("unhandled trap in user mode");
	}
}
